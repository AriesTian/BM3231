#include "include.h"

volatile uint32 *p_APB_XVER_ADDR   = (volatile uint32*)  APB_XVER_BASE ;
volatile uint32 XVR_ANALOG_REG_BAK[16]={0};
extern void delay_ms(unsigned int tt);
void kmod_calibration(void) 
{
	uint32 value;
	uint32 value_kcal_result;

	BK3000_XVR_REG_0x01 = XVR_ANALOG_REG_BAK[1]  = 0x65F9364C;
	
	BK3000_XVR_REG_0x25 |= (1<<12);
	delay_ms(1);
	BK3000_XVR_REG_0x25 |= (1<<13);
	
	delay_ms(1);
	
	BK3000_XVR_REG_0x25 |= (1<<16);
	delay_ms(50);
	value = BK3000_XVR_REG_0x12;
	 
	value = ((value >> 16) & 0x1fff);
	
	value_kcal_result = ((160*256/value)&0x1ff) - 20;

	BK3000_XVR_REG_0x25 &= (~(1<<12));
	BK3000_XVR_REG_0x25 &= (~(1<<13));

	BK3000_XVR_REG_0x30 &= (~(0x1ff<<21));
	BK3000_XVR_REG_0x30 |= (value_kcal_result<<21);
		
	BK3000_XVR_REG_0x25 &= (~(1<<16));
	BK3000_XVR_REG_0x01 = XVR_ANALOG_REG_BAK[1]  = 0x65F936CC;

}

void xver_initial(void)
{
    //ZGF@20140411: Find-Me CEVA SW: Reg09=0xA4251C08, Set Reg09[26]=1 to enable External 32K
    //ZGF@20140903: 
    //  Initialize the XVR based on the Debussy debug of BK3231.case_hidtest
    //  Verified by the BK3231S block test of "CEVA DM IP + BK24_BB + XVR"
    //  Analog SPI Registers are keep same as BK3431 test firmware.
    //
    //ZGF@20150112: 
    //  Analog SPI registers use the values defined in BK3231S_Application_Note.xls
    //  For AMS and real chip, set TxModulator frequency direction equal to 1.
    //  freq_dir=1: REG0x31=0x0000066A. freq_dir=0: REG0x31=0x0000026A
    //
    //MingSheng@20150121
    //  0x6  0x3D2B120F  psen=-90dBm wo eq. 0x9  0x18006000  48M PLL setting. 
    //
    //ZGF@20150126 
    //  DPLL power-up controlled by SW: pwd_digpll_vco=1. pwd_digpll_cp=1. pwd_digpll_pfd=1. digpll_pwd_spi=0.
    //  Enable test 48M PLL output: ck48MtstEn=1
    //  

#if 1
    //Analog Registers
    BK3000_XVR_REG_0x00 = XVR_ANALOG_REG_BAK[0]  = 0x041025FB;
    BK3000_XVR_REG_0x01 = XVR_ANALOG_REG_BAK[1]  = 0x65F936CC;
    BK3000_XVR_REG_0x02 = XVR_ANALOG_REG_BAK[2]  = 0x41083441;
    BK3000_XVR_REG_0x03 = XVR_ANALOG_REG_BAK[3]  = 0x809FEC00;
    BK3000_XVR_REG_0x04 = XVR_ANALOG_REG_BAK[4]  = 0x7F91FE90;
    BK3000_XVR_REG_0x05 = XVR_ANALOG_REG_BAK[5]  = 0x05490A0B;
    BK3000_XVR_REG_0x06 = XVR_ANALOG_REG_BAK[6]  = 0x3D2B120f;
    BK3000_XVR_REG_0x07 = XVR_ANALOG_REG_BAK[7]  = 0xc000480E;//0xc000480A;
    BK3000_XVR_REG_0x08 = XVR_ANALOG_REG_BAK[8]  = 0x07A4A028;
    //BK3000_XVR_REG_0x09 = XVR_ANALOG_REG_BAK[9]  = 0x18006000;
    BK3000_XVR_REG_0x09 = XVR_ANALOG_REG_BAK[9]  = 0x19407D00;//0x19507D00;// Set bit[22]=1, bit[12]=1, bit[11]=1, bit[10]=1. bit[9]=0
#ifdef  _KEYBOARD__ 
    BK3000_XVR_REG_0x0A = XVR_ANALOG_REG_BAK[10] = 0xc0016208;//VDD_SPI=1.2V
#else
    BK3000_XVR_REG_0x0A = XVR_ANALOG_REG_BAK[10] = 0xc0036208;//VDD_SPI=1.5V
#endif
    BK3000_XVR_REG_0x0B = XVR_ANALOG_REG_BAK[11] = 0x00000000;
    BK3000_XVR_REG_0x0C = XVR_ANALOG_REG_BAK[12] = 0x00000000;
    BK3000_XVR_REG_0x0D = XVR_ANALOG_REG_BAK[13] = 0x00000000;
    BK3000_XVR_REG_0x0E = XVR_ANALOG_REG_BAK[14] = 0x00000000;
    BK3000_XVR_REG_0x0F = XVR_ANALOG_REG_BAK[15] = 0x00000000;
    //-------------------------------------------------------
    
    BK3000_XVR_REG_0x10=0x00103232;
    BK3000_XVR_REG_0x11=0x15311910;
    BK3000_XVR_REG_0x12=0x00000056;
    BK3000_XVR_REG_0x13=0x00000000;
    BK3000_XVR_REG_0x14=0x00080000;
    BK3000_XVR_REG_0x15=0x00000000;
    BK3000_XVR_REG_0x16=0x00000000;
    BK3000_XVR_REG_0x17=0x00000000;
    BK3000_XVR_REG_0x18=0x000001DE;
    BK3000_XVR_REG_0x19=0x00000000;
    BK3000_XVR_REG_0x1A=0x00000000;
    BK3000_XVR_REG_0x1B=0x00000000;
    BK3000_XVR_REG_0x1C=0x00000000;
    BK3000_XVR_REG_0x1D=0x00000000;
    BK3000_XVR_REG_0x1E=0x00000000;
    BK3000_XVR_REG_0x1F=0x00000000;
    BK3000_XVR_REG_0x20=0x00A57977;
    BK3000_XVR_REG_0x21=0x0295E500;
    BK3000_XVR_REG_0x22=0x96000011;
    BK3000_XVR_REG_0x23=0xA0000000;
    BK3000_XVR_REG_0x24=0x00000400;//0x00000780;
    BK3000_XVR_REG_0x25=0x02300000;//0x00300000;
    BK3000_XVR_REG_0x26=0x58000800;
    BK3000_XVR_REG_0x27=0x0008F100;
    BK3000_XVR_REG_0x28=0x03030000;
    BK3000_XVR_REG_0x29=0x00001100;
    BK3000_XVR_REG_0x2A=0X305a303d;//0x406A404D;
    BK3000_XVR_REG_0x2B=0x00000000;
    BK3000_XVR_REG_0x2C=0x00000000;
    BK3000_XVR_REG_0x2D=0x0034b041;//0x0038B441;
    BK3000_XVR_REG_0x2E=0x00000000;
    BK3000_XVR_REG_0x2F=0x00000000;
    BK3000_XVR_REG_0x30=0x201000A3 ;//(0x201000A3 ---2016.11.30)  ;//0x174110A3;   0x20100193;
    BK3000_XVR_REG_0x31=0x000000AA;
    BK3000_XVR_REG_0x32=0xFFFF8080;
    BK3000_XVR_REG_0x33=0x0000029B;
    BK3000_XVR_REG_0x34=0x00000000;
    BK3000_XVR_REG_0x35=0x00000000;
    BK3000_XVR_REG_0x36=0x00000000;
    BK3000_XVR_REG_0x37=0x00000000;
    BK3000_XVR_REG_0x38=0x361C8011;
    BK3000_XVR_REG_0x39=0xC0008400;
    BK3000_XVR_REG_0x3A=0x00000000;
    BK3000_XVR_REG_0x3B=0x3F541280;
    BK3000_XVR_REG_0x3C=0x9728051E;
    BK3000_XVR_REG_0x3D=0x83FD8D14;
    BK3000_XVR_REG_0x3E=0x83828F87;
    BK3000_XVR_REG_0x3F=0x0001811B;//0x0000811B;
    BK3000_XVR_REG_0x40=0x01000000;
    BK3000_XVR_REG_0x41=0x07050402;
    BK3000_XVR_REG_0x42=0x120F0C0A;
    BK3000_XVR_REG_0x43=0x221E1A16;
    BK3000_XVR_REG_0x44=0x35302B26;
    BK3000_XVR_REG_0x45=0x4B45403A;
    BK3000_XVR_REG_0x46=0x635D5751;
    BK3000_XVR_REG_0x47=0x7C767069;
    BK3000_XVR_REG_0x48=0x968F8983;
    BK3000_XVR_REG_0x49=0xAEA8A29C;
    BK3000_XVR_REG_0x4A=0xC5BFBAB4;
    BK3000_XVR_REG_0x4B=0xD9D4CFCA;
    BK3000_XVR_REG_0x4C=0xE9E5E1DD;
    BK3000_XVR_REG_0x4D=0xF5F3F0ED;
    BK3000_XVR_REG_0x4E=0xFDFBFAF8;
    BK3000_XVR_REG_0x4F=0xFFFFFFFE;

    
    //BK3000_XVR_REG_0x09 |= 0x100;
    
#endif   

   kmod_calibration();

}


